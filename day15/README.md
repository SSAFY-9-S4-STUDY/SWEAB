# Day15 Code Review

## 김한주 > 서재현
- B 14888 : 이게 DFS가 가능한 문제였나요...? 생각도 못 했네요 
- B 14889 : 함수명이 굉장히 직관적이네요 ㅋㅋㅋ. 망설임없이 순열을 사용했었는데, 이 풀이를 보니 반성하게됩니다... cnt와 방문여부를 조작하여 팀 구분하는 거 배워가요
- B 16234 : 조건이 많아서 저도 따로 함수로 연산을 뺏습니다 ㅎㅎ. bfs를 이용해서 깔끔하게 잘 푸신 것 같습니다.
- B 4803  : 재귀를 이용한 방법 굉장히 참신하네요. boolean값을 리턴으로 두어 조건문에 재귀함수를 두는 것 한 수 배워갑니다.

## 김관형 > 김한주
- B 14888 :
- B 14889 : 
- B 16234 : 
- B 4803  :

## 이장원 > 김관형
- B 14888 :
- B 14889 : 
- B 16234 : 
- B 4803  :

## 김주연 > 이장원
- B 14888 :
- B 14889 : 
- B 16234 : 
- B 4803  :

## 류동훈 > 김주연
- B 14888 : 역시 태양신답게 완벽하게 빛나는 풀이법 잘봤습니다. 주석 하나 없이 너 스스로 이해하거라 라는 깊은 가르침이 담긴 코드 덕분에 일일이 경우의 수를 직접만들어서 풀었던 제 자신을 반성하는 계기가 되었습니다. 앞으로는 태양신처럼 완벽하고 아름답게 풀겠습니다.
- B 14889 : 역시 태양신답게 신문물 itertools combination을 어린 중생에게 하사해주셔서 감사합니다. 이렇게 간단히 풀 수 있다니 이마를 탁치고 갑니다.
- B 16234 : 역시 태양신답게 flag를 활용해 while을 탈출하는 조건부터 전체 맵까지 한 번에 수정하는 bfs함수까지 뭐 하나 센스가 깃들지 않은 부분이 없는 코드라 감탄만 하고 갑니다.
- B 4803  : 역시 태양신답게 문제에서 주어진 트리는 정점이 n개면 간선이 n - 1개라는 힌트는 가뿐히 무시하고 내가 옳다! 출제자보다 내가 더 잘푼다!를 펑범한 bfs코드를 비틀어 visited없이 q에 추가하고 중복되면 트리가 아니라는 코드에 담아내 미천한 중생에게 큰 가르침을 선사해주셔서 감사합니다.
- 
## 윤지현 > 류동훈
- B 14888 : 중간에 정체 경우의 수 구하려고 for문 돌리신 것 같은데(아니라면 죄송) `import math` `math.factorial(n)` 한 번 써보세요!
- B 14889 : 저는 조합 경우 찾고 모든 경우 다 했는데 차이가 0이면 바로 return 해버리네요. 백트래킹 배워갑니다.
- B 16234 : 동훈님 코드에서 일부분만 함수로 뺐을 뿐인데 왜 제껀 하나가 계속 틀릴까요..ㅠㅠ visited 초기화하려고 while문 처음에 이중 for문 돌리셨는데 `visited = [[] for _]`를 `swi = 0`이랑 같이 while문 시작할 때 적어주면 첫번째 턴에서 visited 초기화하는 불필요한 연산 줄일 수 있을 것 같아요. 그리고 제가 재현님한테 리뷰 받았던 부분인데 (#재현아! #고마워!) 인구 수 바꿔주는 부분에서 나누기 연산을 `change_lst` 길이만큼 하게 되는데 for문 앞에 변수로 저장해두고 활용해봐도 좋을 것 같아요.
- B 4803  : 저랑 거의 비슷하게 풀었는데 동훈님이 주연님 리뷰다신거 보니까 미천한 중생2도 가르침을 얻으러 태양신 코드 보러 가야겠군요.

## 문요환 > 윤지현
- B 14888 : 진짜 보자마자 조합식인줄알았는데 dfs는 생각도 못했습니다 ^__^ 앞으로는 더 넓게 사고하는 습관을 들이도록 하겠습니다.
- B 14889 : zip을 통해 한번에 묶으니까 좀 더 깔끔해보이네요 배워갑니다
- B 16234 : 재현이 말처럼 bfs를 따로 안빼고 코드안에 넣어두는게 더 깔끔해 보이기도하고 쭉 보다가 느낀건데 변수명들이 알아보기 쉬워서 좋네요
- B 4803  : 이거 풀다가 tc하나씩 올려주는 조건 넣는 위치를 어디로 줘야 젤 예쁠지 고민하다가 머리아팠는데 후배님꺼 읽다보니 답이 좀 나오네요 

## 박원서 > 문요환
- B 14888 : itertools.permutations() 함수를 이용해 조합식의 경우의 수를 다 판단해 주자 생각한 것이 같았습니다. 다만 똑같은 조합식이 나오는 경우를 줄여줄 수 있다면 좋을 것 같습니다. 저는 각 최대, 최소를 찾아주는 방법으로 배열을 copy해서 pop했는데, 이게 굉장히 무거운 방식이라 요환님처럼 각 배열의 수를 참조하면서 result를 갱신하는 것이 훨씬 가벼운 방법입니다. 배워갑니다~
- B 14889 : 숫자 배열로 이용해서 우리가 쓸 숫자들을 itertools.combinations() 함수로 가져온 것이 저랑 같았습니다. 다만 14888과 같이, 중복되는 부분들을 지울 수 있습니다. combinations() 함수 구현방식을 보면 sort된 결과가 나오기 때문에, `team_a`를 딱 반으로 가르면 그 뒷부분은 결국 `team_b`에서 반복되는 조합들이라 버릴 수 있습니다. 전체 n의 갯수를 줄이는 것도 생각해보기 좋은 부분이라 말씀드려봅니다.
- B 16234 : `조건 주기 귀찮아서 대충 하려다가 더욱 돌아가버린 코드.py` 요환님 코드 보니까 조건이 간단하게 딱 떨어지네요.. 요환님처럼 정석대로 할걸.. 요행 바랬다가 죽을뻔했슴다..
- B 4803  : 아.. 장렬히 산화했군요... 문제 읽기가 엄청 중요하다 느껴집니다. 조건 주는게 문제 속에 있다보니 문제 잘못 읽은걸로 안풀린거 깨달았을 때 멘탈이 갈리거든요..ㅠㅠ 스터디로 여러 문제 만나면 계속 깨부하며 배워가실테니 다음에 더 잘 푸실겁니다. 화이팅이요!

## 임준수 > 박원서
- B 14888 :  
- B 14889 :  
- B 16234 : 
- B 4803  :

## 서재현 > 임준수
- B 14888 : ~~아오 준수꺼 코멘트 달라고 리드미까지 직접 만들었는데 아직 문제 안풀었네;;;;;;;;~~  
이 문제 구글링 해보니까 콤비네이션 말고 DFS로 훨씬 빠르게 푸는 방법이 있었다고 하던데, 임자 코드 보니까 이 방법인듯 싶습니다. 이밖에 좀 콤팩트하게 구현한 코드 중에는 주연님 코드가 있는데 기회되면 읽어보시는 거 추천드려용
- B 14889 : DFS를 통해 팀 나눠주고 각 팀별 능력치의 차이값 구현까지 읽기 쉽게 잘 구현해주셨습니다.
- B 16234 : 저와 같은 로직으로 풀어서 읽기 수월했습니다. 저는 bfs 부분은 따로 빼서 함수로 만들었는데, 오히려 함수로 안빼고 while문에 코드를 풀어놓은게 가독성으로나 코드줄 수로나 더 깔끔한 거 같네요ㅠㅠ
- B 4803  : no comment. 매우 깔끔
