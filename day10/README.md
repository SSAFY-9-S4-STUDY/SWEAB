# Day10 Code Review

## 김한주 > 류동훈

- B 1874: 저도 비슷한 방식으로 풀었는데 거의 4000ms 넘게 뜨더라구요. 시간을 더 줄이려면 좀 더 획기적인 방법이 필요할 거 같네요.  
코드 깔끔하고 이해하기 쉬워서 좋습니다!
- B 1931: 아마 백만장자랑 비슷한 부류의 문제라고 생각되네요. sort 쓰실 때 `sort(key = lambda x:(x[1], x[0])` 이런 식으로 한 줄로 정렬하는 것도 좋을 것 같아요
- <b>B 25632</b>: 이 문제가 이렇게 짧게 풀 수 있는 건줄 몰랐네요...  
```python
for i in range(K - 1, N):
    for j in range(K - 1, M):
        ans.append(sr[i + 1][j + 1] - sr[i + 1][j - K + 1] - sr[i - K + 1][j + 1] + sr[i - K + 1][j - K + 1])
```
이 코드를 `range(K, N+1)`과 `range(K, M+1)`으로 바꾸고 연산부분에서 `i+1`나 `j+1`들을 `i`와 `j`로 바꾸는 것도 연산을 줄이는데 좀 도움이 될 것 같습니다.

## 김관형 > 김주연

- B 1874: 스택으로 직접 push, pop 해서 sample을 만드는 코드네요!
저는 입력되는 숫자를 기준으로 다음 입력 숫자에 대해서 그 차이 중 이미 출력된 숫자를 제외한 만큼 `+` 출력하고 `-` 한개 출력하는 식으로 했어요!
- B 1931: 저는 복잡하게 생각했는데, 아이디어가 너무 좋네요! 코드도 깔끔합니다!
- B 25632: 이 문제 fail했는데 주연님 코드 보고 공부해보겠습니다.

## 이장원 > 박원서

- B 1874: result에 +와 -를 '\n'과 결합하는 방식을 보면서 저렇게 생각할 수도 있었네를 생각했고, while문을 잘 쓴다는 인상을 받았어요!
- B 1931: '새 풀이' 부분은 저랑 푼 부분이 비슷했고, 위에 이전 풀이에서는 bfs라고 적은 부분의 전까지는 이해가 되나 이후는 설명을 들어야할 거 같아서 다가오는 주에 물어볼게용!
- B 25632: 해당 문제는 저도 못풀어서 원서형 코드를 읽어보면서 복습할 수 있었습니다!! 누적합 아이디어는 알아두면 언젠가는 또 요긴하게 쓸 수 있을 거 같아요!!

## 김주연 > 임준수

- **B 1874** : 저는 이문제 엄청 어려웠는뎀.... 엄청 쉽게 푸셨네여 지났지만 코드 리뷰해주셔도 댈듯 합니당 ㅋㅋ 
- B 1931:
- B 25632

## 박원서 > 서재현

- B 1874:
- B 1931:
- B 25632

## 임준수 > 김한주

- B 1874:
- B 1931:
- B 25632

## 서재현 > 김관형

- B 1874: 코드 따라가면서 답이 나오는건 확인했는데, 로직을 제가 제대로 이해를 못했습니다ㅠ 내일 만나서 여쭙고 다시 comment 할게요!!
- B 1931: 코드가 굉장히 깔끔하고 제 코드와 같은 로직이어서 이해하기 쉬웠어요! 코드중에  `arr.sort(key=lambda x:(x[1], x[0]))` 부분은 예전에 저희가 문제 풀면서 습득한 코드였던 거 같은데 잘 활용하신 거 같습니다!!
- B 25632: 형 저도 구글링해놓고 아직 이해 못했는데 ㅋㅋ 같이 이해하는 날이 오면 좋겠습니다. 고생하셨어요 ㅎㅎ

## 류동훈 > 이장원

- B 1874 : input을 받음과 동시에 push pop하는 게 효율적이고 좋았습니다. status도 좋았습니다. 저 같은 경우에는 item != m 이라면 break 하고 출력에 my_stack에 무언가가 남아있다면 NO를 출력하는 식으로 짰는데 status가 직관적이고 깔끔한 것 같습니다.
- B 1931 : sort(key = lambda x : (x[1], x[0]) 가 효율적이고 좋았습니다. 한 수 배웠습니다. 
- B 25632 : 'B'의 값은 K**2 - 'W' 입니다! 이 걸 적용하면 연산을 반으로 줄일 수 있을 듯 합니다!
