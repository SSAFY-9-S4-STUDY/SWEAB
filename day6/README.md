# Day6 Code review

## 김한주 > 박원서
- B 11650 : counting 변수 선언 하고, 결과 출력할 땐 사용 안 하신 것 같은데 그 용도가...? sort 사용할 때 key = lambda x:(조건1,조건2) 이런 식으로 튜플을 활용하면 2개 이상의 정렬 기준을 세울 수 있습니다!
- B 11729 : 코드 깔끔하고 좋은 것 같습니다! 그런데 return 1을 하게 되면 print하면서 그 결과값도 같이 출력되는데 어떻게 처리하셨나요??
- B 1181 : sort를 써서 깔끔하게 처리한 것 같습니다!
- B 2798 : M - 카드합을 리스트에 넣어서 최솟값을 찾는 것 보단 그냥 넣고 max 돌리는 게 연산량이 적을 것 같아요!

## 김관형 > 임준수
- B 11650 : 깔끔하네요! 저도 내장함수 써서 크게 feedback할 부분은 없습니다.
- B 11729 : `hanoi(N-1, a, 6-a-b)` 이런 식으로 쓸 수 있군요! 다만 주석을 달아주면 더 이해하기에 용이할 것 같아요.
- B 1181 : 저도 sorted 내장 함수 썼는데 반갑네욤! 다만 2~7줄까지 word_lst = set(input() for _ in range(n)) 한번에 써줄 수 있을거 같아요.
- B 2798 : check_lst 라는 변수에 리스트를 따로 할당하고 append 하기 보다는 max_num 변수를 할당하고 sum_card를 바로 비교하여 값을 바꾸는 작업이 더 빠를거 같아요.

## 이장원 > 서재현
- B 11650 : 
- B 11729 :
- B 1181 :
- B 2798 :

## 김주연 > 김한주
- B 11650 : 
- B 11729 : 저랑 동일하게 풀었기 때문에 따로 피드백 드릴 점은 없습니다. (굳이 차이를 찾자면 저는 N 번째 블럭 옮기는 것을 hanoi() 쓰지 않고 직접 print 했음) 저는 처음에 END 변수를 바꿀 수 있다는 걸 놓쳐서 N 이 짝수인 경우와 홀수인 경우 나눠서 풀다가 시간 어엄청 뺏겼어요; 이 문제 너무 충격적이었습니다. 고생하셨습니당
- B 1181 :
- **B 2798** : COMBINATION 조합 만드는 3중 for 문 저는 고민하다가 그냥 모듈 import 했습니당. 해당 코드 스터디원분들 모두 공유하면 좋을 듯 합니다. + 나중에 도움 될 듯.

## 박원서 > 김관형
- B 11650 : 저도 내장함수, input 대신 sys로 백준 데이터 받기 등등 시간 줄일 수 있는거 다 해봤는데 안되더라고요... 저희가 배운 sorting 기술로는 안되는거 같아요!! 그래서 그냥 x 따로 y 따로 할 수 있게 백만 곱해서 했습니다. 한주 풀이가 정석인거 같아서 한주 풀이 보시면서 공부하시는게 더 도움되실거같아요!

- **B 11729** : 이것이 바로 수학과? 이것이 바로 수학과? 이것이 바로 수학과? 이것이 바로 수학과? 대박 저는 리턴에서 옮기는 수식을 받아줬는데, 수식이란게 필요가 없었네요..
- B 1181 : set으로 중복을 지우고 시작하는게 저랑 차이였습니다. 저는 중복되는거 제외하고 받는 list를 새로 만들었는데, 이거보단 관형님 풀이가 속도가 훨씬 빠를 거 같아요!
- B 2798 : 매번 최대최소를 리스트에 담는 저를 다시한번 더 꼬집습니다.. 그리고 i부터 범위잡는걸 저도 생각했지만, 에러가 날까 안했는데 생각해보니 그러면 j에서 빈값을 주어 k에서는 에러가 안나는군요.

## 임준수 > 이장원
- B 11650 : 
- B 11729 :
- B 1181 :
- B 2798 :

## 서재현 > 김주연
- **B 11650** : <br> *sorry, no comment. u know it was easy.*
- **B 11729** : <br> `'start', 'end', 'path'`처럼 바로 의미를 알 수 있도록 변수를 지정해서 주석 없이도 이해하기 수월했습니다. 혹시 구글링 없이 구현 한거라면 님은 아마 천재?
- **B 1181** : <br> (1) 저도 문제풀면서 '단어 길이'와 '사전'순으로 동시에 정렬할 수 있는 방법을 계속 찾다가 실패했는데.. 주연님이 `sorted(word_dict.items(), key=lambda x: (x[1], x[0]))`를 통해서 잘 구현해주셨네요:)  <br> (2) 또 중복된 단어 입력받을 때에도 `dict.update()`를 써서 더 간편하게 구현하신 부분이 인상깊었습니다.
- **B 2798** : <br> `combinations(cards, 3)`를 통해 간편하게 풀 수 있다는 점도 잘 배웠습니다. 하지만 한번씩은 다중 for문을 돌려가면서 원시적으로 풀어보시는 것도 추천드려용~ 고생하셨습니다:)
